import multiprocessing
import win32com.client
import pythoncom
import logging
import time
from datetime import datetime
import re
import tkinter as tk
from tkinter import filedialog
import pandas as pd

def convert(filename):
    try:
        print(f"Converting file: {filename}")
        excel = win32com.client.gencache.EnsureDispatch('Excel.Application')
        wb = excel.Workbooks.Open(filename)

        excel.DisplayAlerts = False
        wb.DoNotPromptForConvert = True
        wb.CheckCompatibility = False
        wb.SaveAs(r'C:\Users\opd901\Desktop\SAS-CCV\UPLOAD\DATAMART-BUILDER.xlsx', FileFormat=51, ConflictResolution=2)
        excel.Application.Quit()
        print("Conversion succeded")
    except Exception as e:
        print(f"Conversion ERROR: {e}")

def get_dizionario_progetti(filename):
    dizionario = {}
    dependencies = {}
    df = pd.read_excel(filename,sheet_name=1,header=1).sort_values('ORDINE ESECUZIONE')
    df_filtered = df[df['TENERE']==1][['riferimento_tabella','macro','dipendenze']]
    #print(df)
    for index,row in df_filtered.iterrows():
        if pd.isna(row['dipendenze']):
            dependencies[row['macro']]=[]
        else:
            dependencies[row['macro']]=row['dipendenze'].split(',')
        dizionario[row['macro']]=[row['riferimento_tabella'][5:].split('_',1)[1],row['riferimento_tabella'][5:].upper()]
       
       
    #for tab in df[df['TENERE']==1]['riferimento_tabella']:
        #print(tab[5:])
    #    dizionario[tab[5:].split('_',1)[1].upper()]=tab[5:].upper()
    return dependencies, dizionario

# Funzione regular expression per estrarre la stringa datetime dal log di un programma SAS.
def extract_date_from_text(text, search_string):
    # Costruzione del pattern di ricerca dinamico basato sulla stringa di ricerca fornita
    pattern = fr"{re.escape(search_string)}\s+(\d{{2}}[A-Z]{{3}}\d{{2}}:\d{{2}}:\d{{2}}:\d{{2}})"
    match = re.search(pattern, text)
    if match:
        return match.group(1)
    return None
   
# Funzione per eseguire codice SAS in EG; il codice restituisce il log con data creazione della tabella puntata dalla variabile tabella.
def execute_check(project,tabella):

    sasprog_text  = f"\
    options nonotes nosource nomprint nosymbolgen nomlogic nomcompile;\
    proc sql noprint; select memname,crdate into :name, :crdate from sashelp.vtable where libname = 'LIBOUT' and memname ='{tabella}';\
    %put &name &crdate;\
    "
    code_collection = project.codecollection
    sasprog = code_collection.add
    sasprog.text = sasprog_text
    sasprog.run
    return sasprog.log.text

# Funzione per convertire la stringa in un oggetto datetime
def parse_datetime(date_str):
    return datetime.strptime(date_str, "%d%b%y:%H:%M:%S")


def check_flows(flows,log_filename):
    for flow in flows:
        logs = []
        filename = log_filename+".txt"
        for item in flow.Items:
            if item.type in (1,3,23):
                try:
                    log = item.log.text
                    with open(filename,'a') as f:
                        f.write(log)
                except:
                    with open(filename,'a') as f:
                        f.write(f"Flow:{flow.name} Item:{item.name} -- NO LOG/n")
                       
def logging_setup():
        # Setup logging within the process
    logname = 'logger.txt'
    format_msg = '%(asctime)s - %(name)s %(levelname)s %(message)s'
    logging.basicConfig(filename=logname, filemode='a', format=format_msg, datefmt='%y%m%d %H:%M:%S', level=logging.DEBUG)

def launch_project(nameid,prjfile,tabella_check,dependency_tracker, project_status):

    # Initialize COM for this process
    #time.sleep(2)
    pythoncom.CoInitialize()
   
    logging_setup()
   
    logging.info(f"{prjfile}: Starting project ")
    #prj_name = 'check.egp'
    prj_name = 'Clinico/'+prjfile+'.egp'
    #print(prj_name)
    print(nameid,prjfile,tabella_check,prj_name)
   
   
    dependencies = dependency_tracker[nameid]

    print("\n",dependencies,type(dependencies))
    if dependencies:
        while not all(project_status.get(dep) == 'completed' for dep in dependencies):
            print(nameid,' is waiting ', dependencies)
            time.sleep(10)
    # Use DispatchEx for independent COM instances
    print(nameid," all deps completed; starting")
    saseg_app = win32com.client.DispatchEx("SASEGObjectModel.Application.7.1")
    logging.info(f"{prjfile}: Opening {prj_name}")
    prj_object = saseg_app.Open(prj_name, "")
    #parm_list = prj_object.Parameters
    #parm = parm_list.Item(0)
    #parm.Value = area
   
    try:
        logging.info(f"{prjfile}: Running {prj_name}")
        start_time = datetime.now()
        prj_object.Run()
        stop_time = datetime.now()
        elapsed_time = stop_time - start_time
        project_status[nameid]='completed'
        logging.info(f"{prjfile}: finished in {elapsed_time}")
    except Exception as e:
        logging.error(f"Error running project: {e}")
        project_status[nameid]='failed'
    finally:
        try:
            logging.info(f"{prjfile}: Starting check creation date: {tabella_check}")
            try:
                saslog = execute_check(prj_object,tabella_check)
                try:
                    creation_date = extract_date_from_text(saslog,tabella_check)
                    creation_date = parse_datetime(creation_date)
                except:
                    print(f"there is no table named: {tabella_check}")
                    creation_date = datetime(1900, 1, 1, 0, 0, 0)
                logging.info(f"{prjfile}: Tabella creata {creation_date}")
                if creation_date < start_time:
                    print(f"{prjfile}: Something went wrong")
                    print(check_flows(prj_object.ContainerCollection,prjfile))
                else:
                    print(f"Table {tabella_check} build")
            except Exception as sasprog_error:
                print(sasprog_error,saslog)
                saslog = ""
            #print(saslog)
            prj_object.Close()
            logging.info(f"{prjfile}: Project {prj_name} closed")
        except Exception as e:
            logging.error(f"Error closing the project {e}")
   
    # Uninitialize COM for this process
    pythoncom.CoUninitialize()


if __name__ == "__main__":
    root = tk.Tk()
    root.withdraw()
    filename = filedialog.askopenfilename()
    convert(filename)

    dependencies, dizionario_progetti = get_dizionario_progetti(filename)
    #print(dependencies)
    #print(dizionario_progetti)
    # Create a list to keep track of processes
    #dependencies = {
    #    'ProjectB': ['ProjectA'],
    #    'ProjectC': ['ProjectB'],
    #}



    project_status = {project: 'not started' for project in dizionario_progetti}

    manager = multiprocessing.Manager()
    dependency_tracker = manager.dict(dependencies)
    status_tracker = manager.dict(project_status)
    processes = []

    for nameid,values in dizionario_progetti.items():
        # Create a Process object for each area
        process = multiprocessing.Process(target=launch_project, args=(nameid,values[0], values[1], dependency_tracker, status_tracker))
        processes.append(process)
        process.start()
        # Optional: add a delay between starting each process if necessary
        time.sleep(10)

    # Wait for all processes to complete
    for process in processes:
        process.join()

    print("All projecT instances launched via multiprocessing")
